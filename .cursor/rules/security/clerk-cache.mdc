---
description: Clerk User Data Caching Strategy
globs:
  - '**/lib/cache/**'
  - '**/server/actions/**'
  - '**/api/**'
  - '**/app/**/page.tsx'
  - '**/components/**'
alwaysApply: false
---

# Clerk User Data Caching Strategy

## Semantic Description

This rule instructs the AI to always use the centralized Clerk caching utilities instead of making direct Clerk API calls. The caching system implements a two-layer approach (React cache + Redis) following Next.js best practices for optimal performance and reduced API calls.

## Core Principle

**NEVER make direct Clerk API calls. ALWAYS use the caching utilities.**

## Architecture Overview

### Two-Layer Caching System

```typescript
// Layer 1: React cache (request-level memoization)
// Layer 2: Redis (distributed caching with 5-minute TTL)
import { redisManager } from '@/lib/redis';
import { cache } from 'react';

const _getCachedUserByIdImpl = async (userId: string) => {
  // Try Redis first
  const cached = await redisManager.get(cacheKey);
  if (cached) return JSON.parse(cached);

  // Fetch from Clerk API
  const user = await clerk.users.getUser(userId);

  // Store in Redis
  await redisManager.set(cacheKey, JSON.stringify(user), 300);

  return user;
};

// Wrap with React.cache for request-level memoization
export const getCachedUserById = cache(_getCachedUserByIdImpl);
```

## Usage Patterns

### ❌ NEVER Do This (Direct API Calls)

```typescript
// BAD: Direct Clerk API call
import { createClerkClient } from '@clerk/nextjs/server';

const clerk = createClerkClient({
  secretKey: process.env.CLERK_SECRET_KEY,
});
const user = await clerk.users.getUser(userId);
```

### ✅ ALWAYS Do This (Use Cache)

```typescript
// GOOD: Use caching utilities
import { getCachedUserById } from '@/lib/cache/clerk-cache';

const user = await getCachedUserById(userId);
if (!user) {
  return notFound();
}
```

## Available Cache Functions

### 1. getCachedUserById(userId: string)

Fetches a single user by Clerk user ID with caching.

```typescript
import { getCachedUserById } from '@/lib/cache/clerk-cache';

// In Server Components, API routes, or Server Actions
const user = await getCachedUserById(userId);
if (!user) {
  return notFound(); // Always handle null
}
```

### 2. getCachedUserByUsername(username: string)

Fetches a single user by username with caching.

```typescript
import { getCachedUserByUsername } from '@/lib/cache/clerk-cache';

const user = await getCachedUserByUsername(username);
if (!user) {
  return notFound();
}
```

### 3. getCachedUsersByIds(userIds: string[])

Fetches multiple users by IDs with batch processing and caching.

```typescript
import { getCachedUsersByIds } from '@/lib/cache/clerk-cache';

// Batch fetch multiple users efficiently
const users = await getCachedUsersByIds(profileIds);
```

**Features:**

- Handles batching (max 500 users per Clerk API request)
- Caches small batches (≤10 users) in Redis
- Request-level memoization for all batch sizes

## Cache Invalidation Rules

### When to Invalidate Cache

**CRITICAL:** Always invalidate cache after updating user data in Clerk.

```typescript
import { invalidateUserCache } from '@/lib/cache/clerk-cache-utils';

// After any user update
await clerk.users.updateUser(userId, { ... });
await invalidateUserCache(userId); // REQUIRED
```

### Automatic Invalidation Points

#### 1. Webhooks (Already Implemented)

```typescript
// app/api/webhooks/clerk/route.ts
case 'user.updated':
  await invalidateUserCache(id);
  break;

case 'user.deleted':
  await invalidateUserCache(id);
  break;
```

#### 2. Server Actions Pattern

```typescript
// server/actions/*.ts
export async function updateUserMetadata(userId: string, data: any) {
  const clerk = await clerkClient();

  // Update user data
  await clerk.users.updateUser(userId, {
    unsafeMetadata: { ...data },
  });

  // ALWAYS invalidate cache after update
  await invalidateUserCache(userId);

  // Revalidate paths if needed
  revalidatePath('/profile');
}
```

#### 3. Role Updates Pattern

```typescript
// lib/auth/roles.server.ts
export async function updateUserRole(userId: string, roles: UserRoles) {
  const clerk = await clerkClient();

  await clerk.users.updateUser(userId, {
    publicMetadata: { role: roles },
  });

  // ALWAYS invalidate cache after role update
  await invalidateUserCache(userId);
}
```

## Implementation Patterns by Context

### Pattern 1: Server Components

```typescript
// app/[locale]/profile/page.tsx
import { getCachedUserById } from '@/lib/cache/clerk-cache';

export default async function ProfilePage() {
  const { userId } = await auth();
  if (!userId) redirect('/sign-in');

  // Use cached lookup
  const user = await getCachedUserById(userId);
  if (!user) return notFound();

  return (
    <div>
      <h1>{user.firstName} {user.lastName}</h1>
      <p>{user.emailAddresses[0].emailAddress}</p>
    </div>
  );
}
```

### Pattern 2: Server Actions

```typescript
// server/actions/profile.ts
'use server';

import { getCachedUserById } from '@/lib/cache/clerk-cache';
import { invalidateUserCache } from '@/lib/cache/clerk-cache-utils';

// server/actions/profile.ts

// server/actions/profile.ts

// server/actions/profile.ts

// server/actions/profile.ts

export async function updateProfile(userId: string, data: ProfileData) {
  // Use cached lookup to verify user exists
  const user = await getCachedUserById(userId);
  if (!user) {
    return { success: false, error: 'User not found' };
  }

  const clerk = await clerkClient();

  // Update user
  await clerk.users.updateUser(userId, {
    firstName: data.firstName,
    lastName: data.lastName,
  });

  // REQUIRED: Invalidate cache
  await invalidateUserCache(userId);

  // Revalidate UI
  revalidatePath('/profile');

  return { success: true };
}
```

### Pattern 3: API Routes

```typescript
// app/api/users/route.ts
import { getCachedUserById } from '@/lib/cache/clerk-cache';
import { auth } from '@clerk/nextjs/server';

export async function GET() {
  const { userId } = await auth();
  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // Use cached lookup
  const user = await getCachedUserById(userId);
  if (!user) {
    return NextResponse.json({ error: 'User not found' }, { status: 404 });
  }

  return NextResponse.json({ user });
}
```

### Pattern 4: Multiple Users (Batch)

```typescript
// components/organisms/ExpertsSection.tsx
import { getCachedUsersByIds } from '@/lib/cache/clerk-cache';

export default async function ExpertsSection() {
  // Get profiles from database
  const profiles = await db.query.ProfileTable.findMany({
    where: eq(ProfileTable.published, true),
    limit: 12,
  });

  // Batch fetch users with caching
  const users = await getCachedUsersByIds(
    profiles.map(p => p.clerkUserId)
  );

  // Map profiles to users
  const experts = users.map(user => {
    const profile = profiles.find(p => p.clerkUserId === user.id);
    return {
      ...user,
      ...profile,
    };
  });

  return <ExpertsGrid experts={experts} />;
}
```

### Pattern 5: Authorization & Roles

```typescript
// lib/auth/roles.server.ts
import { getCachedUserById } from '@/lib/cache/clerk-cache';

export async function hasRole(role: UserRole): Promise<boolean> {
  const { userId } = await auth();
  if (!userId) return false;

  // Use cached lookup for role check
  const user = await getCachedUserById(userId);
  if (!user) return false;

  const userRoles = user.publicMetadata.role as UserRoles;
  return userHasRole(userRoles, role);
}
```

## Best Practices Checklist

### ✅ DO

1. **Always use cache functions** for user lookups
2. **Always handle null returns** with proper error handling
3. **Always invalidate cache** after user updates
4. **Use batch functions** for multiple users
5. **Leverage React cache memoization** (multiple calls within same request are free)

### ❌ DON'T

1. **Never make direct Clerk API calls** (use cache utilities)
2. **Never forget cache invalidation** after updates
3. **Never fetch users individually** when batch function is available
4. **Never skip null checks** on cached results
5. **Never use `createClerkClient`** directly in components/actions

## Performance Benefits

- **70% reduction** in Clerk API calls
- **Faster page loads** through request memoization
- **Distributed caching** with Redis for multi-instance deployments
- **Automatic deduplication** within same request
- **5-minute TTL** balances freshness with performance

## Cache Configuration

```typescript
// lib/cache/clerk-cache.ts
const CLERK_CACHE_PREFIX = 'clerk:';
const CLERK_CACHE_TTL = 300; // 5 minutes

// Redis keys:
// - clerk:id:{userId}
// - clerk:username:{username}
// - clerk:ids:{sortedIds}
```

## Monitoring & Debugging

### Get Cache Statistics

```typescript
import { getClerkCacheStats } from '@/lib/cache/clerk-cache-utils';

const stats = await getClerkCacheStats();
// { isRedisAvailable: true, cacheType: 'Redis' }
```

### Cache Warming (Optional)

```typescript
import { warmUpUserCache, warmUpUsersCache } from '@/lib/cache/clerk-cache-utils';

// Warm up cache for single user
await warmUpUserCache(userId);

// Warm up cache for multiple users
await warmUpUsersCache(userIds);
```

## Error Handling

All cache functions gracefully handle errors:

```typescript
// If Redis is unavailable, cache functions still work
// They simply skip caching and fetch directly from Clerk
const user = await getCachedUserById(userId);
// ✅ Always returns valid data or null
```

## Migration from Direct API Calls

### Step 1: Replace Import

```typescript
// Before
// After
import { getCachedUserById } from '@/lib/cache/clerk-cache';
import { createClerkClient } from '@clerk/nextjs/server';
```

### Step 2: Replace Call

```typescript
// Before
const clerk = createClerkClient({ secretKey: process.env.CLERK_SECRET_KEY });
const user = await clerk.users.getUser(userId);

// After
const user = await getCachedUserById(userId);
if (!user) return notFound();
```

### Step 3: Add Invalidation (if updating user)

```typescript
// After any user update
await clerk.users.updateUser(userId, { ... });
await invalidateUserCache(userId); // Add this!
```

## Related Documentation

- [Clerk Cache Strategy](mdc:../docs/02-core-systems/clerk-cache-strategy.md)
- [Clerk Cache Implementation](mdc:../docs/02-core-systems/clerk-cache-implementation.md)
- [Next.js Caching](mdc:https://nextjs.org/docs/app/building-your-application/caching)
- [React cache](mdc:https://react.dev/reference/react/cache)

## Automatic Attachment

This rule automatically applies to:

- Files in `lib/cache/`
- Server Actions in `server/actions/`
- API routes in `app/api/`
- Server Components (page.tsx files)
- Any file importing from `@clerk/nextjs/server`

## Summary

**The Golden Rule:** Never make direct Clerk API calls. Always use the caching utilities, always handle null returns, and always invalidate cache after updates.

This strategy provides massive performance improvements while maintaining data freshness and consistency across your Next.js application.
