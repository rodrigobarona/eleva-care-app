---
description: Server Actions Patterns
globs: ['src/server/**/*.ts']
---

# Server Actions Patterns

## Authentication

All server actions MUST verify authentication first:

```typescript
'use server';

import { withAuth } from '@workos-inc/authkit-nextjs';

export async function myAction(data: FormData) {
  const { user, organizationId } = await withAuth();
  if (!user) throw new Error('Unauthorized');

  // Process authenticated action
}
```

## Input Validation with Zod

Always validate inputs before processing:

```typescript
'use server';

import { z } from 'zod';
import { withAuth } from '@workos-inc/authkit-nextjs';

const UpdateProfileSchema = z.object({
  name: z.string().min(2).max(100),
  bio: z.string().max(500).optional(),
  specialties: z.array(z.string()).max(10),
});

export async function updateProfile(data: FormData) {
  const { user } = await withAuth();
  if (!user) throw new Error('Unauthorized');

  const validated = UpdateProfileSchema.parse({
    name: data.get('name'),
    bio: data.get('bio'),
    specialties: data.getAll('specialties'),
  });

  await db.update(profiles)
    .set(validated)
    .where(eq(profiles.userId, user.id));

  updateTag('profile', `profile-${user.id}`);
}
```

## Cache Invalidation

Choose the correct invalidation strategy:

```typescript
import { updateTag, revalidateTag, refresh } from 'next/cache';

// updateTag() -- Immediate (user sees changes right away)
export async function createPost(data: FormData) {
  const post = await db.insert(posts).values(validated);
  updateTag('posts');
  updateTag(`post-${post.id}`);
  redirect(`/posts/${post.id}`);
}

// revalidateTag() -- Background (stale-while-revalidate)
export async function updateArticle(id: string) {
  await db.update(articles).set(data).where(eq(articles.id, id));
  revalidateTag(`article-${id}`);
}

// refresh() -- Client-side refresh without page reload
export async function markAsRead(id: string) {
  await db.update(notifications).set({ read: true }).where(eq(notifications.id, id));
  refresh();
}
```

## Error Handling

Return structured results instead of throwing in form actions:

```typescript
'use server';

type ActionResult<T = void> = 
  | { success: true; data: T }
  | { success: false; error: string };

export async function createBooking(data: FormData): Promise<ActionResult<{ id: string }>> {
  try {
    const { user } = await withAuth();
    if (!user) return { success: false, error: 'Unauthorized' };

    const validated = BookingSchema.safeParse({
      expertId: data.get('expertId'),
      date: data.get('date'),
    });

    if (!validated.success) {
      return { success: false, error: validated.error.issues[0].message };
    }

    const booking = await db.insert(bookings).values({
      ...validated.data,
      userId: user.id,
    });

    updateTag('bookings');
    return { success: true, data: { id: booking.id } };
  } catch (error) {
    Sentry.captureException(error);
    return { success: false, error: 'An unexpected error occurred' };
  }
}
```

## Data Access with RLS

For health data, always use org-scoped database:

```typescript
import { getOrgScopedDb } from '@/lib/integrations/neon/rls-client';

export async function getHealthRecords() {
  const { user, organizationId } = await withAuth();
  if (!user || !organizationId) throw new Error('Unauthorized');

  const orgDb = await getOrgScopedDb(organizationId);
  return orgDb.select().from(healthRecords);
}
```

## Optimistic Updates Pattern

Pair server actions with `useOptimistic` on the client:

```typescript
// Server action
'use server';
export async function toggleLike(postId: string) {
  const { user } = await withAuth();
  if (!user) throw new Error('Unauthorized');
  await db.insert(likes).values({ postId, userId: user.id });
  updateTag(`post-${postId}`);
}

// Client component
'use client';
import { useOptimistic } from 'react';

export function LikeButton({ postId, liked }: { postId: string; liked: boolean }) {
  const [optimisticLiked, setOptimisticLiked] = useOptimistic(liked);

  async function handleLike() {
    setOptimisticLiked(!optimisticLiked);
    await toggleLike(postId);
  }

  return <button onClick={handleLike}>{optimisticLiked ? '‚ù§Ô∏è' : 'ü§ç'}</button>;
}
```

## File Organization

```
src/server/
‚îú‚îÄ‚îÄ actions/              # Server actions (mutations)
‚îÇ   ‚îú‚îÄ‚îÄ appointments.ts
‚îÇ   ‚îú‚îÄ‚îÄ bookings.ts
‚îÇ   ‚îú‚îÄ‚îÄ profiles.ts
‚îÇ   ‚îî‚îÄ‚îÄ payments.ts
‚îú‚îÄ‚îÄ queries/              # Data fetching (reads)
‚îÇ   ‚îú‚îÄ‚îÄ experts.ts
‚îÇ   ‚îî‚îÄ‚îÄ appointments.ts
‚îî‚îÄ‚îÄ utils/                # Shared server utilities
```

## Checklist

Before committing server actions:

- [ ] Authentication verified with `withAuth()`
- [ ] Inputs validated with Zod schema
- [ ] Correct cache invalidation (`updateTag` / `revalidateTag` / `refresh`)
- [ ] Health data uses `getOrgScopedDb()` (not raw `db`)
- [ ] PHI access logged via `logAuditEvent()`
- [ ] Errors caught and reported to Sentry
- [ ] Structured return type (not throwing in form actions)

## Related Agent Skills

When working on server actions, consider invoking these skills:
- `stripe-integration` -- payment processing in server actions
- `workos-authkit-nextjs` -- authentication patterns
- `neon-drizzle` -- database queries and mutations
- `security-review` -- security audit of server-side code
