---
description: Sentry Error Monitoring Rules
globs: ['src/app/**/*.{ts,tsx}', 'src/components/**/*.{ts,tsx}', 'src/lib/**/*.ts']
alwaysApply: true
---

# Sentry Error Monitoring Rules

## Project Configuration

- **Organization**: elevacade
- **Project**: eleva-care
- **DSN**: Use `NEXT_PUBLIC_SENTRY_DSN` environment variable
- **Features Enabled**: Error Monitoring, Tracing, Session Replay, User Feedback, Logs

## File Structure

| File                        | Purpose                                  |
| --------------------------- | ---------------------------------------- |
| `instrumentation-client.ts` | Client-side SDK initialization (browser) |
| `sentry.server.config.ts`   | Server-side SDK initialization (Node.js) |
| `sentry.edge.config.ts`     | Edge runtime SDK initialization          |
| `src/instrumentation.ts`    | Next.js instrumentation hook             |
| `next.config.ts`            | Sentry build configuration               |

## Tracing Examples

Spans should be created for meaningful actions within applications like button clicks, API calls, and function calls.
Use the `Sentry.startSpan` function to create a span.
Child spans can exist within a parent span.

### Custom Span Instrumentation in Component Actions

The `name` and `op` properties should be meaningful for the activities in the call.
Attach attributes based on relevant information and metrics from the request.

```typescript
function TestComponent() {
  const handleTestButtonClick = () => {
    // Create a transaction/span to measure performance
    Sentry.startSpan(
      {
        op: 'ui.click',
        name: 'Test Button Click',
      },
      (span) => {
        const value = 'some config';
        const metric = 'some metric';

        // Metrics can be added to the span
        span.setAttribute('config', value);
        span.setAttribute('metric', metric);

        doSomething();
      },
    );
  };

  return (
    <button type="button" onClick={handleTestButtonClick}>
      Test Sentry
    </button>
  );
}
```

### Custom Span Instrumentation in API Calls

```typescript
async function fetchUserData(userId: string) {
  return Sentry.startSpan(
    {
      op: 'http.client',
      name: `GET /api/users/${userId}`,
    },
    async () => {
      const response = await fetch(`/api/users/${userId}`);
      const data = await response.json();
      return data;
    },
  );
}
```

## Session Replay

Session Replay is enabled in `instrumentation-client.ts` and records user sessions for debugging.

- **Sample Rate**: 10% of sessions in production, 100% in development
- **Error Sessions**: 100% of sessions with errors are recorded

### Privacy Settings

```typescript
Sentry.replayIntegration({
  maskAllText: false, // Set to true to mask all text
  blockAllMedia: false, // Set to true to block images/videos
});
```

## User Feedback

User Feedback widget is enabled and allows users to submit bug reports.

- Automatically injected via `feedbackIntegration()`
- Color scheme follows system preference
- Accessible via "Report a Bug" button

## Logs

Where logs are used, ensure Sentry is imported using `import * as Sentry from "@sentry/nextjs"`.
Logging is enabled by default via `enableLogs: true`.
Reference the logger using `const { logger } = Sentry`.

### Console Integration

The `consoleLoggingIntegration` automatically captures `console.error` and `console.warn` calls:

```typescript
Sentry.consoleLoggingIntegration({
  levels: ['error', 'warn'],
});
```

### Logger Examples

`logger.fmt` is a template literal function that should be used to bring variables into the structured logs.

```typescript
const { logger } = Sentry;

logger.trace('Starting database connection', { database: 'users' });
logger.debug(logger.fmt`Cache miss for user: ${userId}`);
logger.info('Updated profile', { profileId: 345 });
logger.warn('Rate limit reached for endpoint', {
  endpoint: '/api/results/',
  isEnterprise: false,
});
logger.error('Failed to process payment', {
  orderId: 'order_123',
  amount: 99.99,
});
logger.fatal('Database connection pool exhausted', {
  database: 'users',
  activeConnections: 100,
});
```

## Error Handling Patterns

### Capturing Exceptions Manually

```typescript
import * as Sentry from '@sentry/nextjs';

try {
  await riskyOperation();
} catch (error) {
  Sentry.captureException(error, {
    tags: { operation: 'riskyOperation' },
    extra: { userId, context: 'some context' },
  });
  throw error; // Re-throw if needed
}
```

### Adding Context to Errors

```typescript
Sentry.setUser({ id: userId, email: userEmail });
Sentry.setTag('feature', 'booking');
Sentry.setExtra('bookingDetails', { eventId, expertId });
```

## Tunnel Route

Client-side errors are sent through `/monitoring` tunnel route to bypass ad-blockers.
This is configured in `next.config.ts` via `tunnelRoute: '/monitoring'`.

## Source Maps

Source maps are automatically uploaded during builds when `SENTRY_AUTH_TOKEN` is set.
This enables readable stack traces in production.

## Environment Variables

```bash
# Required - Public DSN for client-side
NEXT_PUBLIC_SENTRY_DSN="https://..."

# Required - Auth token for source map uploads (keep secret!)
SENTRY_AUTH_TOKEN="sntrys_..."

# Optional - Server-side DSN (defaults to NEXT_PUBLIC_SENTRY_DSN)
SENTRY_DSN="https://..."
```

## Debugging with Sentry MCP Tools

When investigating production errors, use the Sentry MCP tools available in this workspace:
- `search_issues` -- find issues by description or impact
- `get_issue_details` -- get full stacktrace and context for a specific issue
- `analyze_issue_with_seer` -- AI-powered root cause analysis with code fix suggestions
- `search_events` -- count errors, aggregate data, find specific events

Organization slug: `elevacade`, Project: `eleva-care`

## Related Agent Skills

When working on error monitoring and debugging, consider invoking these skills:
- `sentry-fix-issues` -- patterns for fixing Sentry-reported errors
- `sentry-setup-logging` -- structured logging setup with Sentry SDK
