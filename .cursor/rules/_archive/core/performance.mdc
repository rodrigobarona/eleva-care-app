---
description: Performance Optimization Guidelines for Next.js 16
globs:
alwaysApply: false
---

# Performance Optimization Guidelines for Next.js 16

## 1. Server Components Optimization

### Use Server Components by Default

```typescript
// Good: Server Component with async params (Next.js 16)
export default async function ExpertList({
  params,
}: {
  params: Promise<{ category: string }>
}) {
  const { category } = await params
  const experts = await getExperts(category)
  return <ExpertListView experts={experts} />
}

// Bad: Unnecessary Client Component
'use client'
export default function ExpertList() {
  const { data: experts } = useQuery(['experts'])
  return <ExpertListView experts={experts} />
}
```

## 2. Next.js 16 Caching with 'use cache' Directive

### Basic 'use cache' Usage

```typescript
import { cacheLife, cacheTag } from 'next/cache';

// Cache function results
async function getExperts() {
  'use cache';
  cacheLife({ expire: 300 }); // 5 minutes
  cacheTag('experts');

  const experts = await db.experts.findMany();
  return experts;
}

// Cache with multiple tags
async function getExpertProfile(id: string) {
  'use cache';
  cacheLife({ expire: 600, stale: 300 }); // 10 min expire, 5 min stale
  cacheTag('experts', `expert-${id}`);

  const expert = await db.experts.findUnique({ where: { id } });
  return expert;
}
```

### Mixed Caching Strategies

```typescript
import { Suspense } from 'react'
import { connection } from 'next/server'
import { cookies } from 'next/headers'
import { cacheLife, cacheTag } from 'next/cache'

// Static product data - prerendered at build time
async function getProduct(id: string) {
  'use cache'
  cacheTag(`product-${id}`)

  return db.products.find({ where: { id } })
}

// Shared pricing data - cached at runtime in remote handler
async function getProductPrice(id: string) {
  'use cache: remote'
  cacheTag(`product-price-${id}`)
  cacheLife({ expire: 300 }) // 5 minutes

  return db.products.getPrice({ where: { id } })
}

// User-specific recommendations - private cache per user
async function getRecommendations(productId: string) {
  'use cache: private'
  cacheLife({ expire: 60 }) // 1 minute

  const sessionId = (await cookies()).get('session-id')?.value

  return db.recommendations.findMany({
    where: { productId, sessionId },
  })
}

export default async function ProductPage({
  params
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  const product = await getProduct(id)

  return (
    <div>
      <ProductDetails product={product} />

      <Suspense fallback={<PriceSkeleton />}>
        <ProductPriceComponent productId={id} />
      </Suspense>

      <Suspense fallback={<RecommendationsSkeleton />}>
        <ProductRecommendations productId={id} />
      </Suspense>
    </div>
  )
}
```

### Cache Invalidation

```typescript
'use server';

import { revalidateTag, updateTag } from 'next/cache';

// Immediate invalidation (read-your-writes)
export async function updateProduct(id: string, data: any) {
  await db.products.update(id, data);

  // User sees changes immediately
  updateTag(`product-${id}`);
  updateTag('products');
}

// Stale-while-revalidate
export async function updateProductPrice(id: string, price: number) {
  await db.products.updatePrice(id, price);

  // Users see stale data while fresh data fetches
  revalidateTag(`product-price-${id}`, 'max');
}
```

## 3. Image Optimization

### Next.js Image Component

```typescript
// Good: Optimized Image
import Image from 'next/image'

export function Avatar({ src }: { src: string }) {
  return (
    <Image
      src={src}
      width={64}
      height={64}
      alt="User avatar"
      placeholder="blur"
      loading="lazy"
    />
  )
}
```

## 4. Route Optimization

### Route Segments

- Use route groups for code organization
- Implement parallel routes for complex layouts
- Use loading.tsx for streaming
- Use Suspense boundaries for progressive rendering

### Route Segment Config (Next.js 16)

```typescript
// Force dynamic rendering
export const dynamic = 'force-dynamic'

// Force static rendering
export const dynamic = 'force-static'

// Revalidate every 60 seconds
export const revalidate = 60

// Override fetch caching
export const fetchCache = 'force-cache' // or 'force-no-store'
```

## 5. Data Fetching Optimization

### Parallel Data Fetching

```typescript
// Good: Parallel requests
export default async function Page({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params

  const [user, posts, comments] = await Promise.all([
    getUser(id),
    getUserPosts(id),
    getUserComments(id),
  ])

  return <UserProfile user={user} posts={posts} comments={comments} />
}

// Bad: Sequential requests
export default async function Page({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  const user = await getUser(id)
  const posts = await getUserPosts(id) // Waits for user
  const comments = await getUserComments(id) // Waits for posts

  return <UserProfile user={user} posts={posts} comments={comments} />
}
```

### Streaming with Suspense

```typescript
import { Suspense } from 'react'

export default async function Page({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params

  return (
    <div>
      {/* Fast content renders immediately */}
      <Header />

      {/* Slow content streams in */}
      <Suspense fallback={<PostsSkeleton />}>
        <Posts userId={id} />
      </Suspense>

      <Suspense fallback={<CommentsSkeleton />}>
        <Comments userId={id} />
      </Suspense>
    </div>
  )
}

async function Posts({ userId }: { userId: string }) {
  const posts = await getSlowPosts(userId)
  return <PostList posts={posts} />
}
```

## 6. Bundle Optimization

### Dynamic Imports

```typescript
import dynamic from 'next/dynamic'

// Good: Dynamic import with loading state
const Chart = dynamic(() => import('@/components/Chart'), {
  loading: () => <ChartSkeleton />,
  ssr: false, // Disable SSR if not needed
})

// Good: Dynamic import with named export
const AdvancedEditor = dynamic(
  () => import('@/components/Editor').then((mod) => mod.AdvancedEditor),
  {
    loading: () => <EditorSkeleton />,
  }
)
```

## 7. Caching Strategy

### Two-Layer Caching Pattern

```typescript
import { redisManager } from '@/lib/redis';
import { cache } from 'react';

// Layer 1: React cache (request-level memoization)
// Layer 2: Redis (distributed caching)
const _getDataImpl = async (id: string) => {
  // Try Redis first
  const cached = await redisManager.get(`data:${id}`);
  if (cached) return JSON.parse(cached);

  // Fetch from source
  const data = await fetchData(id);

  // Store in Redis with TTL
  await redisManager.set(`data:${id}`, JSON.stringify(data), 300);

  return data;
};

// Wrap with React.cache for request deduplication
export const getData = cache(_getDataImpl);
```

### Next.js 16 'use cache' with Redis

```typescript
import { redisManager } from '@/lib/redis';
import { cacheLife, cacheTag } from 'next/cache';

async function getExperts() {
  'use cache';
  cacheLife({ expire: 300 }); // 5 minutes
  cacheTag('experts');

  // Try Redis first
  const cached = await redisManager.get('experts');
  if (cached) return JSON.parse(cached);

  // Fetch from database
  const experts = await db.experts.findMany();

  // Store in Redis
  await redisManager.set('experts', JSON.stringify(experts), 300);

  return experts;
}
```

### Clerk User Caching (Required)

**ALWAYS use caching utilities for Clerk user data:**

```typescript
// ✅ GOOD: Use centralized cache
import { getCachedUserById } from '@/lib/cache/clerk-cache'

const user = await getCachedUserById(userId)
if (!user) return notFound()

// ❌ BAD: Direct API calls
const clerk = createClerkClient({ ... })
const user = await clerk.users.getUser(userId) // NEVER DO THIS
```

**Benefits:**

- 70% reduction in API calls
- Request-level deduplication
- 5-minute distributed cache
- Automatic invalidation on updates

See [@file ../security/clerk-cache.mdc](mdc:../security/clerk-cache.mdc) for complete guidelines.

## 8. Database Optimization

### Query Optimization

```typescript
// Good: Optimized query with select
const result = await db
  .select({
    id: experts.id,
    name: experts.name,
    email: experts.email,
  })
  .from(experts)
  .where(eq(experts.status, 'active'))
  .limit(10)

// Bad: Over-fetching
const result = await db
  .select()
  .from(experts)
  .where(eq(experts.status, 'active'))
```

### Pagination

```typescript
async function getExperts(page: number = 1, pageSize: number = 20) {
  'use cache';
  cacheLife({ expire: 300 });
  cacheTag('experts', `experts-page-${page}`);

  const offset = (page - 1) * pageSize;

  const [experts, total] = await Promise.all([
    db.experts.findMany({
      take: pageSize,
      skip: offset,
      orderBy: { createdAt: 'desc' },
    }),
    db.experts.count(),
  ]);

  return {
    experts,
    total,
    page,
    pageSize,
    totalPages: Math.ceil(total / pageSize),
  };
}
```

## Best Practices

### 1. Component Level

- Use Server Components where possible
- Implement proper code splitting
- Optimize images and media
- Minimize client-side JavaScript
- Use Suspense for progressive rendering

### 2. Data Level

- Use Next.js 16 'use cache' directive for function-level caching
- Implement two-layer caching (React cache + distributed)
- **ALWAYS use Clerk cache utilities** (never direct API calls)
- Use parallel data fetching with Promise.all
- Optimize database queries with proper select
- Implement pagination for large datasets
- Invalidate cache after mutations with updateTag()

### 3. Caching Strategy

- Static data: `'use cache'` with long expiration
- Dynamic data: `'use cache: remote'` with short expiration
- Private data: `'use cache: private'` for user-specific content
- Use `cacheTag()` for selective invalidation
- Use `cacheLife()` to control expiration and stale times

### 4. Build Level

- Minimize bundle size with dynamic imports
- Enable compression
- Use production builds
- Monitor performance metrics
- Analyze bundle with `pnpm analyze`

### 5. Monitoring

- Track Core Web Vitals
- Monitor server response times
- Track client-side performance
- Set up alerts for degradation
- Monitor cache hit rates
- Use Vercel Analytics and Speed Insights

## Next.js 16 Caching Checklist

Before committing code:

- [ ] Are you using `'use cache'` directive for cacheable functions?
- [ ] Have you set appropriate `cacheLife()` expiration times?
- [ ] Are you using `cacheTag()` for selective invalidation?
- [ ] For user-specific data: Are you using `'use cache: private'`?
- [ ] For shared runtime data: Are you using `'use cache: remote'`?
- [ ] After mutations: Are you calling `updateTag()` or `revalidateTag()`?
- [ ] For Clerk user data: Are you using `getCachedUserById` instead of direct API calls?
- [ ] Are you handling null returns from cache functions?
- [ ] Are you using Suspense for slow data fetching?
- [ ] Have you implemented proper loading states?

## Cache Invalidation Patterns

### Immediate Updates (Read-Your-Writes)

```typescript
'use server';

import { updateTag } from 'next/cache';

export async function createPost(data: FormData) {
  const post = await db.posts.create({ data });

  // Immediate cache invalidation
  updateTag('posts');
  updateTag(`post-${post.id}`);

  return post;
}
```

### Background Updates (Stale-While-Revalidate)

```typescript
'use server';

import { revalidateTag } from 'next/cache';

export async function updateArticle(id: string, data: any) {
  await db.articles.update(id, data);

  // Users see stale data while fresh data fetches
  revalidateTag(`article-${id}`, 'max');
}
```

### Client Router Refresh

```typescript
'use server';

import { refresh } from 'next/cache';

export async function markNotificationAsRead(id: string) {
  await db.notifications.markAsRead(id);

  // Refresh UI without full page reload
  refresh();
}
```

## Performance Monitoring

### Core Web Vitals

- **LCP (Largest Contentful Paint)**: < 2.5s
- **FID (First Input Delay)**: < 100ms
- **CLS (Cumulative Layout Shift)**: < 0.1

### Server Metrics

- **TTFB (Time to First Byte)**: < 600ms
- **Server Response Time**: < 200ms
- **Database Query Time**: < 100ms

### Caching Metrics

- **Cache Hit Rate**: > 80%
- **Cache Miss Penalty**: < 500ms
- **Cache Invalidation Time**: < 100ms
