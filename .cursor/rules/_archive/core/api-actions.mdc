---
description: Create/update api endpoints and actions
globs:
---

# API, Server Actions, and Mutations Rule for Next.js 16 with App Router

## Semantic Description

This rule instructs the AI to generate production‑ready code for handling APIs, server actions, and mutations in a Next.js 16 application that uses the App Router. The code should:

- Follow Next.js 16 conventions for the App Router by placing API endpoints within the `/app/api/` directory.
- Use Next.js Server Actions for mutations and data-changing operations. Server actions must include the `"use server"` directive.
- Implement proper HTTP methods (GET, POST, PUT, DELETE, etc.) and adhere to RESTful practices where applicable.
- Include robust error handling, input validation, and security measures (e.g., authentication, CSRF protection).
- Be written in TypeScript when possible, ensuring clear type definitions for request and response data.
- Leverage Next.js 16 cache invalidation APIs: `refresh()`, `updateTag()`, and `revalidateTag()` for optimal cache management.

## File Pattern Matching

- **Applies to files located in:**
  - `/app/api/**` – for Next.js API routes.
  - `/app/` files that contain server actions (indicated by the `"use server"` directive).
- **Triggers:**
  - Any file or endpoint referencing API logic, server mutations, or data-changing actions.

## Rule Details & Examples

### 1. API Endpoints in `/app/api/`

- **Guidelines:**
  - Use file-based routing to define endpoints.
  - Implement handlers using HTTP methods.
  - Use built‑in Next.js utilities (like `NextResponse`) for handling responses.
  - Ensure each endpoint validates input and manages errors appropriately.
- **Example:**

  ```ts
  // app/api/appointments/route.ts
  import { NextResponse } from 'next/server';

  // GET /api/appointments
  export async function GET(request: Request) {
    try {
      const appointments = await fetchAppointments(); // custom function to fetch data
      return NextResponse.json(appointments);
    } catch (error) {
      return NextResponse.error();
    }
  }

  // POST /api/appointments
  export async function POST(request: Request) {
    try {
      const data = await request.json();
      // Validate and process data here
      const newAppointment = await createAppointment(data); // custom function to create data
      return NextResponse.json(newAppointment, { status: 201 });
    } catch (error) {
      return NextResponse.json({ error: 'Failed to create appointment' }, { status: 400 });
    }
  }
  ```

  > _Inline Note:_ Use proper input validation and error handling to ensure robust API behavior.

### 2. Server Actions for Mutations

- **Guidelines:**
  - In server actions, include the `"use server"` directive at the top of the file.
  - Define functions that perform mutations or other side effects.
  - Server actions can be invoked from client components via form submissions or fetch requests.
  - Use Next.js 16 cache invalidation APIs after mutations for optimal data freshness.
- **Example:**

  ```ts
  // app/actions/meetings.ts
  'use server';

  import { refresh, revalidateTag, updateTag } from 'next/cache';
  import { redirect } from 'next/navigation';

  // app/actions/meetings.ts

  // app/actions/meetings.ts

  /**
   * Creates a new meeting with immediate cache invalidation.
   *
   * @param {object} data - The meeting data.
   * @param {string} data.title - The meeting title.
   * @param {string} data.date - The meeting date.
   * @returns {Promise<object>} The created meeting object.
   *
   * @example
   * const meeting = await createMeeting({ title: "Team Sync", date: "2025-02-20" });
   */
  export async function createMeeting(data: { title: string; date: string }): Promise<object> {
    // Validate data and perform server-side mutation
    const result = await database.insertMeeting(data); // custom database operation

    // Use updateTag for read-your-writes: immediate cache invalidation
    // User sees their changes right away
    updateTag('meetings');
    updateTag(`meeting-${result.id}`);

    return result;
  }

  /**
   * Updates a meeting notification count with client refresh.
   *
   * @param {string} meetingId - The meeting ID.
   * @returns {Promise<void>}
   */
  export async function markMeetingAsViewed(meetingId: string): Promise<void> {
    await database.updateMeeting(meetingId, { viewed: true });

    // Use refresh() to trigger client-side router refresh
    // Updates UI without full page reload
    refresh();
  }

  /**
   * Updates article data with stale-while-revalidate pattern.
   *
   * @param {string} articleId - The article ID.
   * @returns {Promise<void>}
   */
  export async function updateArticle(articleId: string): Promise<void> {
    await database.updateArticle(articleId);

    // Use revalidateTag with 'max' for stale-while-revalidate
    // Users see stale data while fresh data is fetched in background
    revalidateTag(`article-${articleId}`, 'max');
  }
  ```

  > _Inline Note:_ Choose the right cache invalidation strategy:
  >
  > - `updateTag()` for read-your-writes (immediate updates)
  > - `refresh()` for client-side router refresh
  > - `revalidateTag()` with 'max' for stale-while-revalidate

### 3. Best Practices & Security

- **General Guidelines:**
  - Use TypeScript for strict typing of request bodies and response objects.
  - Secure sensitive endpoints (e.g., using authentication middleware or verifying tokens).
  - Document the endpoint’s purpose, parameters, and potential error responses using JSDoc comments.
  - Organize endpoints and actions in directories that reflect their responsibilities (e.g., grouping related API endpoints under `/app/api/appointments/`).

## Automatic Attachment & References

- **Automatic Inclusion:**
  - This rule should automatically be attached to any file in `/app/api/` or files containing server actions with the `"use server"` directive.
- **References:**
  - @Next.js 16 App Router Documentation
  - @NextResponse API
  - @Server Actions in Next.js
  - @Next.js 16 Cache Invalidation APIs
  - @Next.js 16 Data Fetching Patterns

## Additional Guidelines

- **Testing:**
  - Ensure to include unit and integration tests for API endpoints and server actions using a tool like Jest.
- **Performance:**
  - Optimize endpoints to leverage Next.js 16 caching mechanisms where applicable.
  - Use `fetch()` with appropriate cache options: `{ cache: 'force-cache' }` for static data, `{ cache: 'no-store' }` for dynamic data.
  - Implement `{ next: { revalidate: N } }` for time-based revalidation.
- **Code Modularity:**
  - Break down complex operations into smaller helper functions.
- **Documentation:**
  - Each endpoint and server action should be documented with JSDoc comments, including `@param`, `@returns`, and `@example` tags to facilitate maintainability.

## Next.js 16 Cache Invalidation Strategies

### 1. Read-Your-Writes Pattern (Immediate Updates)

Use `updateTag()` when users need to see their changes immediately:

```ts
'use server';

import { updateTag } from 'next/cache';

export async function createPost(formData: FormData) {
  const post = await db.post.create({ data: formData });

  // Immediate cache invalidation
  updateTag('posts');
  updateTag(`post-${post.id}`);

  return post;
}
```

### 2. Client Router Refresh

Use `refresh()` to update UI components without full page reload:

```ts
'use server';

import { refresh } from 'next/cache';

export async function markNotificationAsRead(notificationId: string) {
  await db.notifications.markAsRead(notificationId);

  // Refresh the notification count in header
  refresh();
}
```

### 3. Stale-While-Revalidate Pattern

Use `revalidateTag()` with 'max' for content where slight delays are acceptable:

```ts
'use server';

import { revalidateTag } from 'next/cache';

export async function updateArticle(articleId: string) {
  await db.articles.update(articleId);

  // Mark as stale, users see old data while new data fetches
  revalidateTag(`article-${articleId}`, 'max');
}
```

## Data Fetching Patterns

### Server Components with Fetch

```ts
// Default: cached until manually invalidated
export default async function Page() {
  const staticData = await fetch('https://...', { cache: 'force-cache' })

  // Dynamic: refetched on every request
  const dynamicData = await fetch('https://...', { cache: 'no-store' })

  // Time-based revalidation
  const revalidatedData = await fetch('https://...', {
    next: { revalidate: 60 } // 60 seconds
  })

  return <div>...</div>
}
```

### Async Params Pattern (Next.js 16)

```ts
export default async function Page({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  const data = await getData(id)

  return <div>{data.title}</div>
}
```
