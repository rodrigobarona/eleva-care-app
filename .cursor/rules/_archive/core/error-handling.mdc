---
description: Error Handling Patterns for Next.js 16
globs:
alwaysApply: false
---

# Error Handling Patterns for Next.js 16

## 1. Error Types

### API Errors

```typescript
export class APIError extends Error {
  constructor(
    message: string,
    public statusCode: number,
    public code: string,
  ) {
    super(message);
    this.name = 'APIError';
  }
}
```

### Validation Errors

```typescript
export class ValidationError extends Error {
  constructor(
    message: string,
    public errors: Record<string, string[]>,
  ) {
    super(message);
    this.name = 'ValidationError';
  }
}
```

## 2. Error Boundaries (Next.js 16)

### App Router Error Boundary

```typescript
// app/error.tsx
'use client'

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  return (
    <div>
      <h2>Something went wrong!</h2>
      <p>{error.message}</p>
      {error.digest && <p>Error ID: {error.digest}</p>}
      <button onClick={reset}>Try again</button>
    </div>
  )
}
```

### Route-Specific Error Boundary

```typescript
// app/dashboard/error.tsx
'use client'

import { useEffect } from 'react'

export default function DashboardError({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  useEffect(() => {
    // Log error to monitoring service
    console.error('Dashboard error:', error)
  }, [error])

  return (
    <div>
      <h2>Dashboard Error</h2>
      <p>{error.message}</p>
      <button onClick={reset}>Try again</button>
    </div>
  )
}
```

### Not Found Handling

```typescript
// app/not-found.tsx
export default function NotFound() {
  return (
    <div>
      <h2>404 - Not Found</h2>
      <p>Could not find the requested resource</p>
    </div>
  )
}
```

## 3. API Error Handling (Next.js 16)

### Server Actions with Cache Invalidation

```typescript
'use server';

import { updateTag } from 'next/cache';

export async function handleAction(data: FormData) {
  try {
    // Action logic
    const result = await processData(data);

    // Invalidate cache on success
    updateTag('data');

    return { success: true, data: result };
  } catch (error) {
    if (error instanceof ValidationError) {
      return { error: true, validationErrors: error.errors };
    }
    if (error instanceof APIError) {
      return { error: true, message: error.message };
    }
    return { error: true, message: 'An unexpected error occurred' };
  }
}
```

### API Route Error Handling

```typescript
// app/api/data/route.ts
import { NextResponse } from 'next/server';

export async function GET(request: Request) {
  try {
    const data = await fetchData();
    return NextResponse.json(data);
  } catch (error) {
    if (error instanceof ValidationError) {
      return NextResponse.json({ error: error.errors }, { status: 400 });
    }
    if (error instanceof APIError) {
      return NextResponse.json({ error: error.message }, { status: error.statusCode });
    }
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
```

## 4. Client-Side Error Handling

### Form Errors

```typescript
export function handleFormError(error: unknown) {
  if (error instanceof ValidationError) {
    return error.errors;
  }
  return { _form: ['An unexpected error occurred'] };
}
```

## 5. Error Logging

### Structured Error Logging

```typescript
export function logError(error: Error, context?: Record<string, unknown>) {
  console.error({
    message: error.message,
    stack: error.stack,
    context,
    timestamp: new Date().toISOString(),
  });
}
```

## Best Practices

1. Always use typed errors
2. Implement proper error boundaries
3. Log errors with context
4. Handle errors at the appropriate level
5. Provide user-friendly error messages
6. Include error recovery mechanisms
7. Monitor and track errors
8. Document error handling patterns
