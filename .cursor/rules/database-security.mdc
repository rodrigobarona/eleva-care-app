---
description: Database and Security Patterns
globs: ['drizzle/**/*.ts', 'lib/auth/**/*.ts', 'lib/stripe/**/*.ts']
---

# Database and Security Patterns

## Database (Drizzle ORM + Neon.tech)

```typescript
import { db } from '@/drizzle/db';
import { and, desc, eq } from 'drizzle-orm';

// Optimized query with select
const users = await db
  .select({
    id: users.id,
    name: users.name,
    email: users.email,
  })
  .from(users)
  .where(eq(users.status, 'active'))
  .limit(20);

// Pagination
const page = 1;
const pageSize = 20;
const offset = (page - 1) * pageSize;

const [items, total] = await Promise.all([
  db.users.findMany({
    take: pageSize,
    skip: offset,
    orderBy: { createdAt: 'desc' },
  }),
  db.users.count(),
]);
```

## Auth (Clerk.com)

```typescript
import { auth } from '@clerk/nextjs/server';
import { getCachedUserById } from '@/lib/cache/clerk-cache';

// ✅ Always use cached helpers
export default async function Page() {
  const { userId } = await auth();
  if (!userId) redirect('/sign-in');

  // Use cache utilities - never direct API
  const user = await getCachedUserById(userId);
  if (!user) return notFound();

  return <ProfileView user={user} />;
}

// ❌ Never do this
const clerk = createClerkClient({ ... });
const user = await clerk.users.getUser(userId); // NEVER!
```

## Payments (Stripe)

```typescript
import { stripe } from '@/lib/stripe';

// Create payment intent
export async function createPayment(amount: number) {
  'use server';

  const { userId } = await auth();
  if (!userId) throw new Error('Unauthorized');

  const paymentIntent = await stripe.paymentIntents.create({
    amount: amount * 100,
    currency: 'usd',
    metadata: { userId },
  });

  return { clientSecret: paymentIntent.client_secret };
}

// Handle webhook
export async function POST(req: Request) {
  const sig = req.headers.get('stripe-signature')!;
  const body = await req.text();

  const event = stripe.webhooks.constructEvent(body, sig, process.env.STRIPE_WEBHOOK_SECRET!);

  switch (event.type) {
    case 'payment_intent.succeeded':
      await handlePaymentSuccess(event.data.object);
      break;
  }

  return new Response('OK');
}
```

## Security Best Practices

1. **Always validate inputs** with Zod:

```typescript
import { z } from 'zod';

const CreatePostSchema = z.object({
  title: z.string().min(1).max(100),
  content: z.string().min(1),
});

export async function createPost(data: FormData) {
  'use server';

  const validated = CreatePostSchema.parse({
    title: data.get('title'),
    content: data.get('content'),
  });

  // Process validated data
}
```

2. **Use environment variables** for secrets:

```typescript
// ✅ Good
const apiKey = process.env.API_KEY!;

// ❌ Never hardcode
const apiKey = 'sk_test_abc123';
```

3. **Implement rate limiting** on API routes
4. **Use HTTPS** for all external API calls
5. **Sanitize user input** before rendering

## Two-Layer Caching

```typescript
import { redisManager } from '@/lib/redis';
import { cache } from 'react';

// Layer 1: React cache (request-level)
// Layer 2: Redis (distributed)
const _getDataImpl = async (id: string) => {
  const cached = await redisManager.get(`data:${id}`);
  if (cached) return JSON.parse(cached);

  const data = await fetchData(id);
  await redisManager.set(`data:${id}`, JSON.stringify(data), 300);

  return data;
};

export const getData = cache(_getDataImpl);
```
